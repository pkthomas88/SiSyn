---
title: "Si/N/P stoich over time"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
library(tidyverse)
library(broom)
library(ggridges)
library(ggpubr)
library(knitr)
library(PerformanceAnalytics)
library(car)
library(MASS)
library(lubridate)
library(scales)
library(lme4)
library(nlme)

theme_set(theme_bw()+
            theme(axis.text=element_text(size=8),
  axis.title.x = element_text(size = 16),
  axis.title.y = element_text(size = 16)))

select <- dplyr::select
```



# Setup for concentrations + ratios vs time

Read in data and check out how many observations of each variable we have to play with

> For now, treating SRP as PO4! But this is probably wrong

```{r}
sisyn <- read_csv("20201111_masterdata_RAW.csv") 

sisyn <- sisyn %>%
  mutate(variable=ifelse(variable=="SRP", "PO4", variable))

unique(sisyn$variable)

sisyn %>% count(variable, sort = TRUE) %>% kable()
```

Spread the data into wide format, make year column, and summarize annual averages into a data table

```{r}
# Spreading data to give each variable a column, averaging values by date/site


sisyn_wide <- sisyn %>% 
  mutate(sample=paste(LTER, site, Sampling.Date, sep="_")) %>%
  pivot_wider(names_from = variable,
              values_from = value,
              values_fn = mean)

# making year into its own column

sisyn_wide <- sisyn_wide %>% 
  mutate(sample.date=date(Sampling.Date)) %>%  
  mutate(year=year(sample.date))

# making the ratios at each sampling point into their own columns

sisyn_wide <- sisyn_wide %>%
  mutate(Si_N = DSi/NOx,
         Si_P = DSi/PO4,
         N_P = NOx/PO4)

# making another dataset of just annual averages for DSi, NOx, and PO4

sisyn_annual <- sisyn_wide %>% 
  group_by(year, LTER, site) %>% 
  summarize(meanDSi = mean(DSi, na.rm=TRUE),
            meanNOx = mean(NOx, na.rm=TRUE),
            meanPO4 = mean(PO4, na.rm=TRUE),
            sd_DSi = sd(DSi, na.rm=TRUE),
            sd_NOx = sd(NOx, na.rm=TRUE),
            sd_PO4 = sd(PO4, na.rm=TRUE),
            meanSi_N = mean(Si_N, na.rm=TRUE),
            meanSi_P = mean(Si_P, na.rm=TRUE),
            meanN_P = mean(N_P)) %>% 
  mutate(site = str_replace_all(site, " ", "_"),
         CV_DSi = sd_DSi/meanDSi,
         CV_NOx = sd_NOx/meanNOx,
         CV_PO4 = sd_PO4/meanPO4)
```


# Concentrations, ratios, and CVs by year and site

## Mean annual DSi

```{r}

ggplot(sisyn_annual, aes(year, meanDSi, group=site))+
  geom_line(stat="smooth", method="lm", se=FALSE, alpha=.5)+
  facet_wrap(~LTER, scales = "free_y")+
  scale_x_continuous(breaks=c(1980, 2000, 2020))+
  theme(strip.text.x = element_text(size = 6))


ggplot(sisyn_annual, aes(year, meanDSi, group=site))+
  #geom_point(alpha=0.2)+
  geom_line(alpha=0.2)+
  facet_wrap(~LTER, scales = "free_y")+
  scale_x_continuous(breaks=c(1980, 2000, 2020))+
  theme(strip.text.x = element_text(size = 6))

```

## CV annual DSi

```{r}
ggplot(sisyn_annual, aes(year, CV_DSi, group=site))+
  geom_line(stat="smooth", method="lm", se=FALSE, alpha=.5)+
  facet_wrap(~LTER, scales = "free_y")+
  scale_x_continuous(breaks=c(1980, 2000, 2020))+
  theme(strip.text.x = element_text(size = 6))

ggplot(sisyn_annual, aes(year, CV_DSi, group=site))+
  #geom_point(alpha=0.2)+
  geom_line(alpha=0.2)+
  facet_wrap(~LTER, scales = "free_y")+
  scale_x_continuous(breaks=c(1980, 2000, 2020))+
  theme(strip.text.x = element_text(size = 6))
```

## Si:N over time

```{r}
ggplot(sisyn_annual, aes(year, meanSi_N, group=site))+
  geom_line(stat="smooth", method="lm", se=FALSE, alpha=.5)+
  facet_wrap(~LTER, scales = "free_y")+
  scale_x_continuous(breaks=c(1980, 2000, 2020))+
  theme(strip.text.x = element_text(size = 6))

ggplot(sisyn_annual, aes(year, meanSi_N, group=site))+
  #geom_point(alpha=0.2)+
  geom_line(alpha=0.2)+
  facet_wrap(~LTER, scales = "free_y")+
  scale_x_continuous(breaks=c(1980, 2000, 2020))+
  theme(strip.text.x = element_text(size = 6))+
  geom_hline(yintercept = 1)

ggplot(sisyn_annual, aes(year, meanSi_N, group = LTER))+
  geom_point(alpha=0.2)+
  geom_smooth(method = 'lm', se=FALSE, aes(color = LTER))+
  scale_x_continuous(breaks=c(1980, 2000, 2020))+
  scale_y_log10()+
  theme(strip.text.x = element_text(size = 6))+
  geom_hline(yintercept = 1)

ggplot(sisyn_annual, aes(year, meanSi_N, group = site))+
  geom_point(alpha=0.2)+
  geom_smooth(method = 'lm', se=FALSE, aes(color = LTER))+
  scale_x_continuous(breaks=c(1980, 2000, 2020))+
  scale_y_log10()+
  theme(strip.text.x = element_text(size = 6))+
  geom_hline(yintercept = 1)
```



```{r}
ggplot(sisyn_annual, aes(year, meanSi_P, group=site))+
  geom_line(stat="smooth", method="lm", se=FALSE, alpha=.5)+
  facet_wrap(~LTER, scales = "free_y")+
  scale_x_continuous(breaks=c(1980, 2000, 2020))+
  theme(strip.text.x = element_text(size = 6))

ggplot(sisyn_annual, aes(year, meanSi_P, group=site))+
  #geom_point(alpha=0.2)+
  geom_line(alpha=0.2)+
  facet_wrap(~LTER, scales = "free_y")+
  scale_x_continuous(breaks=c(1980, 2000, 2020))+
  theme(strip.text.x = element_text(size = 6))
```

# Extracting lots of slopes


## DSi slopes over time

```{r}
#making each column contain DSi conc for each site, since this is the only way I could figure out how to do >400 regressions at once

sisyn_annual_wide_Si <- sisyn_annual %>% 
  select(year, LTER, site, meanDSi) %>% 
  filter(!is.na(meanDSi)) %>% 
  pivot_wider(names_from = site, values_from = meanDSi)

#set number of columns (i.e., sites)

n <- 433


#apply a linear regression for DSi vs year for all sites. the 'as.matrix' part was necessary to make it work, but I am still not totally sure why

my_lms <- lapply(3:n, function(x) lm(as.matrix(sisyn_annual_wide_Si[,x]) ~ year, data=sisyn_annual_wide_Si))


#extracting the slope and intercept from my_lms and turning it into a data frame
                   
coefs <- sapply(my_lms, coef)
coefs <- data.frame(coefs)
#rownames(coef)[1:435] <- myvars #FIGURE OUT HOW TO DO THIS!!!!

#making the coefs data more usable 

coefs <- rownames_to_column(coefs)

coefs_long <- coefs %>% 
  pivot_longer(!rowname,
               names_to = "coeftype",
               values_to="value")
# now we have slopes in long format and can play with those!


coefs_long %>% filter(rowname=="year") %>% 
  ggplot(aes(value))+
  geom_density()+
  #scale_x_log10(labels=comma)+
  #geom_vline(xintercept = 1, linetype='dashed')+
  xlab('Slope of year vs DSi')+
  xlim(-50, 50)


A<- coefs_long %>% 
  filter(rowname=="year", value<0) %>% 
  count()

B <- coefs_long %>% 
  filter(rowname=="year", value>0) %>% 
  count()

pct_pos <- (B/(B+A))*100

pct_pos

```

> so `r pct_pos` of sites have a positive slope for Si:N over time

Use this in case we also want to look at *\R^2* values

```{r}
#same as above but gets list with rsquare values

summaries <- lapply(my_lms, summary)
rquares <- sapply(summaries, function(x) c(r_sq = x$r.squared, 
                                adj_r_sq = x$adj.r.squared))

#same as above but gives p values

pvals <- lapply(summaries, function(x) x$coefficients[, c(1,4)])

```


## DSi slopes over time

```{r}
#making each column contain DSi conc for each site, since this is the only way I could figure out how to do >400 regressions at once

sisyn_annual_wide_CVSi <- sisyn_annual %>% 
  select(year, LTER, site, CV_DSi) %>% 
  filter(!is.na(CV_DSi)) %>% 
  pivot_wider(names_from = site, values_from = CV_DSi)

#set number of columns (i.e., sites)

n <- 384

#list of the columns (sites) which may or may not be useful
#myvars <- as.list(colnames(sisyn_annual_wide[3:435]))

#apply a linear regression for DSi vs year for all sites. the 'as.matrix' part was necessary to make it work, but I am still not totally sure why

my_lms <- lapply(3:n, function(x) lm(as.matrix(sisyn_annual_wide_CVSi[,x]) ~ year, data=sisyn_annual_wide_CVSi))


#extracting the slope and intercept from my_lms and turning it into a data frame
                   
coefs <- sapply(my_lms, coef)
coefs <- data.frame(coefs)
#rownames(coef)[1:435] <- myvars #FIGURE OUT HOW TO DO THIS!!!!

#making the coefs data more usable 

coefs <- rownames_to_column(coefs)

coefs_long <- coefs %>% 
  pivot_longer(!rowname,
               names_to = "coeftype",
               values_to="value")
# now we have slopes in long format and can play with those!


coefs_long %>% filter(rowname=="year") %>% 
  ggplot(aes(value))+
  geom_density()+
  #scale_x_log10(labels=comma)+
  #geom_vline(xintercept = 1, linetype='dashed')+
  xlab('Slope of year vs CV_DSi')+
  xlim(-10, 10)


A<- coefs_long %>% 
  filter(rowname=="year", value<0) %>% 
  count()

B <- coefs_long %>% 
  filter(rowname=="year", value>0) %>% 
  count()

pct_pos <- (B/(B+A))*100

pct_pos

```

> so `r pct_pos` of sites have a positive slope for CV(Si) over time


## DSi:N slopes over time

```{r}
#making each column contain DSi conc for each site, since this is the only way I could figure out how to do >400 regressions at once

sisyn_annual_wide_Si_N <- sisyn_annual %>% 
  select(year, LTER, site, meanSi_N) %>% 
  filter(!is.na(meanSi_N)) %>% 
  pivot_wider(names_from = site, values_from = meanSi_N)

#set number of columns (i.e., sites)

n <- 411

#list of the columns (sites) which may or may not be useful
#myvars <- as.list(colnames(sisyn_annual_wide[3:435]))

#apply a linear regression for DSi vs year for all sites. the 'as.matrix' part was necessary to make it work, but I am still not totally sure why

my_lms <- lapply(3:n, function(x) lm(as.matrix(sisyn_annual_wide_Si_N[,x]) ~ year, data=sisyn_annual_wide_Si_N))
```


```{r}

#extracting the slope and intercept from my_lms and turning it into a data frame
                   
coefs <- sapply(my_lms, coef)
coefs <- data.frame(coefs)
#rownames(coef)[1:435] <- myvars #FIGURE OUT HOW TO DO THIS!!!!

#making the coefs data more usable 

coefs <- rownames_to_column(coefs)

coefs_long <- coefs %>% 
  pivot_longer(!rowname,
               names_to = "coeftype",
               values_to="value")
# now we have slopes in long format and can play with those!
```



Using lapply to get regression coefficients for each site (finally)

found here https://stackoverflow.com/questions/27952653/how-to-loop-repeat-a-linear-regression-in-r

```{r}
coefs_long %>% filter(rowname=="year") %>% 
  ggplot(aes(value))+
  geom_density()+
  #scale_x_log10(labels=comma)+
  #geom_vline(xintercept = 1, linetype='dashed')+
  xlab('Slope of year vs DSi:N')+
  xlim(-50, 50)


coefs_long %>% 
  filter(rowname=="year", value<0) %>% 
  count()



```

> so 61% of sites have a positive slope for Si:N over time

Use this in case we also want to look at *\R^2* values

```{r eval=FALSE, include=FALSE}
#same as above but gets list with rsquare values

summaries <- lapply(my_lms, summary)
rquares <- sapply(summaries, function(x) c(r_sq = x$r.squared, 
                                adj_r_sq = x$adj.r.squared))

#same as above but gives p values

pvals <- lapply(summaries, function(x) x$coefficients[, c(1,4)])

```

